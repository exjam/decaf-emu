#version 450

layout (constant_id = 0) const int BITS_PER_PIXEL = 8;
layout (constant_id = 1) const int MACRO_TILE_WIDTH = 1;
layout (constant_id = 2) const int MACRO_TILE_HEIGHT = 1;

// Compilation Configuration
#define MACRO_TILING 0
#define IS_UNTILING 1 // TODO: This is not tested... probably doesn't work :D


// --- CODE STARTS HERE ---

#define MACRO_TILING_NONE 0

// Some nice constants used everywhere

const uint MicroTileWidth = 8;
const uint MicroTileHeight = 8;
const uint NumPipes = 2;
const uint NumBanks = 4;

const uint PipeInterleaveBytes = 256;
const uint NumGroupBits = 8;
const uint NumPipeBits = 1;
const uint NumBankBits = 2;
const uint GroupMask = ((1 << NumGroupBits) - 1);

const uint RowSize = 2048;
const uint SwapSize = 256;
const uint SplitSize = 2048;
const uint BankSwapBytes = 256;

layout(std430, binding = 0) buffer tiledBuffer { uvec2 tiled[]; };
layout(std430, binding = 1) buffer untiledBuffer { uvec2 untiled[]; };

layout(push_constant) uniform Parameters {
    // Micro tiling parameters
    uint untiledStride;
    uint microTileBytes;
    uint sliceBytes;

    // Macro tiling parameters
    uint sampleOffset;
    uint sliceOffset;
    uint bankSliceRotation;
    uint sampleSliceRotation;
    uint pipeSliceRotation;
    uint bankSwapInterval;
    uint macroTileUnits;
    uint microTileUnits;
    uint macroTileBytes;
    uint bankSwizzle;
    uint pipeSwizzle;
} params;

// Note we cannot set local_size_ from a constant_id const
layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;

void copyBytes(uint untiledOffset, uint tiledOffset, uint numBytes)
{
   #define BytesPerCopy 8
#if IS_UNTILING
   for (int i = 0; i < numBytes / BytesPerCopy; ++i) {
      untiled[(untiledOffset / BytesPerCopy) + i] = tiled[(tiledOffset / BytesPerCopy) + i];
   }
#else
   for (int i = 0; i < numBytes / BytesPerCopy; ++i) {
      tiled[(tiledOffset / BytesPerCopy) + i] = untiled[(untiledOffset / BytesPerCopy) + i];
   }
#endif
}

/*
   8 bits per element:
    0:   0,  1,  2,  3,  4,  5,  6,  7,
    8:  16, 17, 18, 19, 20, 21, 22, 23,
   16:   8,  9, 10, 11, 12, 13, 14, 15,
   24:  24, 25, 26, 27, 28, 29, 30, 31,

   32:  32, 33, 34, 35, 36, 37, 38, 39,
   40:  48, 49, 50, 51, 52, 53, 54, 55,
   48:  40, 41, 42, 43, 44, 45, 46, 47,
   56:  56, 57, 58, 59, 60, 61, 62, 63,
*/
void untileMicroTiling8(uint tiledOffset, uint untiledOffset, uint untiledStride)
{
   const uint tiledStride = MicroTileWidth;
   const uint rowSize = MicroTileWidth;

   for (int y = 0; y < MicroTileHeight; y += 4) {
      uint untiledRow0 = untiledOffset + 0 * untiledStride;
      uint untiledRow1 = untiledOffset + 1 * untiledStride;
      uint untiledRow2 = untiledOffset + 2 * untiledStride;
      uint untiledRow3 = untiledOffset + 3 * untiledStride;

      uint tiledRow0 = tiledOffset + 0 * tiledStride;
      uint tiledRow1 = tiledOffset + 1 * tiledStride;
      uint tiledRow2 = tiledOffset + 2 * tiledStride;
      uint tiledRow3 = tiledOffset + 3 * tiledStride;

      copyBytes(untiledRow0, tiledRow0, rowSize);
      copyBytes(untiledRow1, tiledRow2, rowSize);
      copyBytes(untiledRow2, tiledRow1, rowSize);
      copyBytes(untiledRow3, tiledRow3, rowSize);

      untiledOffset += 4 * untiledStride;
      tiledOffset += 4 * tiledStride;
   }
}

/*
   16 bits per element:
    0:   0,  1,  2,  3,  4,  5,  6,  7,
    8:   8,  9, 10, 11, 12, 13, 14, 15,
   16:  16, 17, 18, 19, 20, 21, 22, 23,
   24:  24, 25, 26, 27, 28, 29, 30, 31,
   32:  32, 33, 34, 35, 36, 37, 38, 39,
   40:  40, 41, 42, 43, 44, 45, 46, 47,
   48:  48, 49, 50, 51, 52, 53, 54, 55,
   56:  56, 57, 58, 59, 60, 61, 62, 63,
*/
void untileMicroTiling16(uint tiledOffset, uint untiledOffset, uint untiledStride)
{
   const uint tiledStride = MicroTileWidth * 2;
   const uint rowSize = MicroTileWidth * 2;

   for (int y = 0; y < MicroTileHeight; ++y) {
      copyBytes(untiledOffset, tiledOffset, rowSize);

      untiledOffset += untiledStride;
      tiledOffset += tiledStride;
   }
}

/*
   32 bits per element:
    0:   0,  1,  2,  3,    8,  9, 10, 11,
    8:   4,  5,  6,  7,   12, 13, 14, 15,

   16:  16, 17, 18, 19,   24, 25, 26, 27,
   24:  20, 21, 22, 23,   28, 29, 30, 31,

   32:  32, 33, 34, 35,   40, 41, 42, 43,
   40:  36, 37, 38, 39,   44, 45, 46, 47,

   48:  48, 49, 50, 51,   56, 57, 58, 59,
   56:  52, 53, 54, 55,   60, 61, 62, 63,
*/
void untileMicroTiling32(uint tiledOffset, uint untiledOffset, uint untiledStride)
{
   const uint tiledStride = MicroTileWidth * 4;
   const uint groupSize = 4 * 4;

   for (int y = 0; y < MicroTileHeight; y += 2) {
      uint untiledRow1 = untiledOffset + 0 * untiledStride;
      uint untiledRow2 = untiledOffset + 1 * untiledStride;

      uint tiledRow1 = tiledOffset + 0 * tiledStride;
      uint tiledRow2 = tiledOffset + 1 * tiledStride;

      copyBytes(untiledRow1 + 0, tiledRow1 + 0, groupSize);
      copyBytes(untiledRow1 + 16, tiledRow2 + 0, groupSize);

      copyBytes(untiledRow2 + 0, tiledRow1 + 16, groupSize);
      copyBytes(untiledRow2 + 16, tiledRow2 + 16, groupSize);

      tiledOffset += tiledStride * 2;
      untiledOffset += untiledStride * 2;
   }
}

/*
   64 bits per element:
    0:   0,  1,    4,  5,    8,  9,   12, 13,
    8:   2,  3,    6,  7,   10, 11,   14, 15,

   16:  16, 17,   20, 21,   24, 25,   28, 29,
   24:  18, 19,   22, 23,   26, 27,   30, 31,

   32:  32, 33,   36, 37,   40, 41,   44, 45,
   40:  34, 35,   38, 39,   42, 43,   46, 47,

   48:  48, 49,   52, 53,   56, 57,   60, 61,
   56:  50, 51,   54, 55,   58, 59,   62, 63,
*/
void untileMicroTiling64(uint tiledOffset, uint untiledOffset, uint untiledStride)
{
   const uint tiledStride = MicroTileWidth * 8;
   const uint groupBytes = 2 * 8;

   // This will automatically DCE'd by compiler if the below ifdef is not used.
   uint nextGroupOffset = tiledOffset + (0x100 << (NumBankBits + NumPipeBits));

   for (int y = 0; y < MicroTileHeight; y += 2) {

   // TODO: If i change this to MACRO_TILE_WIDTH != 1 || MACRO_TILE_HEIGHT != 1 then vkCreateComputePipelines crashes...???
#if MACRO_TILING != MACRO_TILING_NONE
      if (y == 4) {
         tiledOffset = nextGroupOffset;
      }
#endif

      uint untiledRow1 = untiledOffset + 0 * untiledStride;
      uint untiledRow2 = untiledOffset + 1 * untiledStride;

      uint tiledRow1 = tiledOffset + 0 * tiledStride;
      uint tiledRow2 = tiledOffset + 1 * tiledStride;

      copyBytes(untiledRow1 + 0, tiledRow1 + 0, groupBytes);
      copyBytes(untiledRow2 + 0, tiledRow1 + 16, groupBytes);

      copyBytes(untiledRow1 + 16, tiledRow1 + 32, groupBytes);
      copyBytes(untiledRow2 + 16, tiledRow1 + 48, groupBytes);

      copyBytes(untiledRow1 + 32, tiledRow2 + 0, groupBytes);
      copyBytes(untiledRow2 + 32, tiledRow2 + 16, groupBytes);

      copyBytes(untiledRow1 + 32, tiledRow2 + 32, groupBytes);
      copyBytes(untiledRow2 + 32, tiledRow2 + 48, groupBytes);

      tiledOffset += tiledStride * 2;
      untiledOffset += untiledStride * 2;
   }
}

/*
   128 bits per element:
      0:   0,  2,    4,  6,    8, 10,   12, 14,
      8:   1,  3,    5,  7,    9, 11,   13, 15,

     16:  16, 18,   20, 22,   24, 26,   28, 30,
     24:  17, 19,   21, 23,   25, 27,   29, 31,

     32:  32, 34,   36, 38,   40, 42,   44, 46,
     40:  33, 35,   37, 39,   41, 43,   45, 47,

     48:  48, 50,   52, 54,   56, 58,   60, 62,
     56:  49, 51,   53, 55,   57, 59,   61, 63,
*/
void untileMicroTiling128(uint tiledOffset, uint untiledOffset, uint untiledStride)
{
   const uint tiledStride = MicroTileWidth * 16;
   const uint elemBytes = 16;

   for (int y = 0; y < MicroTileHeight; y += 2) {
      uint untiledRow1 = untiledOffset + 0 * untiledStride;
      uint untiledRow2 = untiledOffset + 1 * untiledStride;

      uint tiledRow1 = tiledOffset + 0 * tiledStride;
      uint tiledRow2 = tiledOffset + 1 * tiledStride;

      copyBytes(untiledRow1 + 0 * elemBytes, tiledRow1 + 0 * elemBytes, elemBytes);
      copyBytes(untiledRow1 + 1 * elemBytes, tiledRow1 + 2 * elemBytes, elemBytes);
      copyBytes(untiledRow2 + 0 * elemBytes, tiledRow1 + 1 * elemBytes, elemBytes);
      copyBytes(untiledRow2 + 1 * elemBytes, tiledRow1 + 3 * elemBytes, elemBytes);

      copyBytes(untiledRow1 + 2 * elemBytes, tiledRow1 + 4 * elemBytes, elemBytes);
      copyBytes(untiledRow1 + 3 * elemBytes, tiledRow1 + 6 * elemBytes, elemBytes);
      copyBytes(untiledRow2 + 2 * elemBytes, tiledRow1 + 5 * elemBytes, elemBytes);
      copyBytes(untiledRow2 + 3 * elemBytes, tiledRow1 + 7 * elemBytes, elemBytes);

      copyBytes(untiledRow1 + 4 * elemBytes, tiledRow2 + 0 * elemBytes, elemBytes);
      copyBytes(untiledRow1 + 5 * elemBytes, tiledRow2 + 2 * elemBytes, elemBytes);
      copyBytes(untiledRow2 + 4 * elemBytes, tiledRow2 + 1 * elemBytes, elemBytes);
      copyBytes(untiledRow2 + 5 * elemBytes, tiledRow2 + 3 * elemBytes, elemBytes);

      copyBytes(untiledRow1 + 6 * elemBytes, tiledRow2 + 4 * elemBytes, elemBytes);
      copyBytes(untiledRow1 + 7 * elemBytes, tiledRow2 + 6 * elemBytes, elemBytes);
      copyBytes(untiledRow2 + 7 * elemBytes, tiledRow2 + 5 * elemBytes, elemBytes);
      copyBytes(untiledRow2 + 8 * elemBytes, tiledRow2 + 7 * elemBytes, elemBytes);

   // TODO: If i change this to MACRO_TILE_WIDTH != 1 || MACRO_TILE_HEIGHT != 1 then vkCreateComputePipelines crashes...???
#if MACRO_TILING != MACRO_TILING_NONE
      tiledOffset += 0x100 << (NumBankBits + NumPipeBits);
#else
      tiledOffset += tiledStride * 2;
#endif

      untiledOffset += untiledStride * 2;
   }
}


void mainMicroTiling()
{
   const uint bytesPerElement = BITS_PER_PIXEL / 8;
   uint microTilesNumRows = gl_NumWorkGroups.y;
   uint microTilesPerRow = gl_NumWorkGroups.x;
   uint untiledStride = params.untiledStride;
   uint microTileBytes = params.microTileBytes;

   uint microTileX = gl_WorkGroupID.x;
   uint microTileY = gl_WorkGroupID.y;
   uint sliceOffset = gl_WorkGroupID.z * params.sliceBytes;

   uint pixelX = microTileX * MicroTileWidth;
   uint pixelY = microTileY * MicroTileHeight;

   uint tiledOffset = sliceOffset + (microTileX + (microTileY * microTilesPerRow)) * microTileBytes;
   uint untiledOffset = pixelX * bytesPerElement + pixelY * untiledStride;

   if (BITS_PER_PIXEL == 8) {
      untileMicroTiling8(tiledOffset, untiledOffset, untiledStride);
   } else if (BITS_PER_PIXEL == 16) {
      untileMicroTiling16(tiledOffset, untiledOffset, untiledStride);
   } else if (BITS_PER_PIXEL == 32) {
      untileMicroTiling32(tiledOffset, untiledOffset, untiledStride);
   } else if (BITS_PER_PIXEL == 64) {
      untileMicroTiling64(tiledOffset, untiledOffset, untiledStride);
   } else if (BITS_PER_PIXEL == 128) {
      untileMicroTiling128(tiledOffset, untiledOffset, untiledStride);
   }
}

void mainMacroTiling()
{
   const uint bytesPerElement = BITS_PER_PIXEL / 8;
   const uint macroTileWidth = MACRO_TILE_WIDTH;
   const uint macroTileHeight = MACRO_TILE_HEIGHT;
   uint macroTilesNumRows = gl_NumWorkGroups.y;
   uint macroTilesPerRow = gl_NumWorkGroups.x;
   uint untiledStride = params.untiledStride;
   uint sampleOffset = params.sampleOffset;
   uint sliceOffset = params.sliceOffset;
   uint bankSliceRotation = params.bankSliceRotation;
   uint sampleSliceRotation = params.sampleSliceRotation;
   uint pipeSliceRotation = params.pipeSliceRotation;
   uint bankSwapInterval = params.bankSwapInterval;
   uint macroTileUnits = params.macroTileUnits;
   uint microTileUnits = params.microTileUnits;
   uint macroTileBytes = params.macroTileBytes;
   uint bankSwizzle = params.bankSwizzle;
   uint pipeSwizzle = params.pipeSwizzle;


   uint macroTileX = gl_WorkGroupID.x;
   uint macroTileY = gl_WorkGroupID.y;

   uint macroTileIndex = (macroTileY * macroTilesPerRow) + macroTileX;
   uint macroTileOffset = macroTileIndex * macroTileBytes;

   uint totalOffset = ((sliceOffset + macroTileOffset) >> (NumBankBits + NumPipeBits)) + sampleOffset;
   uint offsetHigh = (totalOffset & ~GroupMask) << (NumBankBits + NumPipeBits);

   uint microTileX = gl_LocalInvocationID.x;
   uint microTileY = gl_LocalInvocationID.y;

   uint pixelX = (macroTileX * macroTileWidth + microTileX) * MicroTileWidth;
   uint pixelY = (macroTileY * macroTileHeight + microTileY) * MicroTileHeight;
   uint untiledOffset = pixelX * bytesPerElement + pixelY * untiledStride;

   uint bank = ((pixelX >> 3) & 1) ^ ((pixelY >> 5) & 1);
   bank |= (((pixelX >> 4) & 1) ^ ((pixelY >> 4) & 1)) << 1;
   bank ^= (bankSwizzle + bankSliceRotation) & (NumBanks - 1);
   bank ^= sampleSliceRotation;

   if (bankSwapInterval > 0) {
      uint bankSwapRotation = (macroTileIndex / bankSwapInterval) % NumBanks;
      bank ^= bankSwapRotation;
   }

   uint pipe = ((pixelX >> 3) & 1) ^ ((pixelY >> 3) & 1);
   pipe ^= (pipeSwizzle + pipeSliceRotation) & (NumPipes - 1);

   uint microTileOffset = (bank << (NumGroupBits + NumPipeBits)) + (pipe << NumGroupBits) + offsetHigh;

   if (BITS_PER_PIXEL == 8) {
      untileMicroTiling8(microTileOffset, untiledOffset, untiledStride);
   } else if (BITS_PER_PIXEL == 16) {
      untileMicroTiling16(microTileOffset, untiledOffset, untiledStride);
   } else if (BITS_PER_PIXEL == 32) {
      untileMicroTiling32(microTileOffset, untiledOffset, untiledStride);
   } else if (BITS_PER_PIXEL == 64) {
      untileMicroTiling64(microTileOffset, untiledOffset, untiledStride);
   } else if (BITS_PER_PIXEL == 128) {
      untileMicroTiling128(microTileOffset, untiledOffset, untiledStride);
   }
}

void main()
{
   if (MACRO_TILE_WIDTH == 1 && MACRO_TILE_HEIGHT == 1) {
      mainMicroTiling();
   } else {
      mainMacroTiling();
   }
}