/*

    WGL loader generated by glad 0.1.33 on Mon Sep 30 18:05:31 2019.

    Language/Generator: C/C++ Debug
    Specification: wgl
    APIs: wgl=1.0
    Profile: -
    Extensions:
        WGL_ARB_create_context,
        WGL_ARB_create_context_profile,
        WGL_ARB_pixel_format,
        WGL_EXT_swap_control
    Loader: True
    Local files: False
    Omit khrplatform: False
    Reproducible: False

    Commandline:
        --api="wgl=1.0" --generator="c-debug" --spec="wgl" --extensions="WGL_ARB_create_context,WGL_ARB_create_context_profile,WGL_ARB_pixel_format,WGL_EXT_swap_control"
    Online:
        https://glad.dav1d.de/#language=c-debug&specification=wgl&loader=on&api=wgl%3D1.0&extensions=WGL_ARB_create_context&extensions=WGL_ARB_create_context_profile&extensions=WGL_ARB_pixel_format&extensions=WGL_EXT_swap_control
*/

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <glad/glad_wgl.h>

void _pre_call_callback_default(const char *name, void *funcptr, int len_args, ...) {
    (void) name;
    (void) funcptr;
    (void) len_args;
}
void _post_call_callback_default(const char *name, void *funcptr, int len_args, ...) {
    (void) name;
    (void) funcptr;
    (void) len_args;
}

static GLADcallback _pre_call_callback = _pre_call_callback_default;
void glad_set_pre_callback(GLADcallback cb) {
    _pre_call_callback = cb;
}

static GLADcallback _post_call_callback = _post_call_callback_default;
void glad_set_post_callback(GLADcallback cb) {
    _post_call_callback = cb;
}

static void* get_proc(const char *namez);

#if defined(_WIN32) || defined(__CYGWIN__)
#ifndef _WINDOWS_
#undef APIENTRY
#endif
#include <windows.h>
static HMODULE libGL;

typedef void* (APIENTRYP PFNWGLGETPROCADDRESSPROC_PRIVATE)(const char*);
static PFNWGLGETPROCADDRESSPROC_PRIVATE gladGetProcAddressPtr;

#ifdef _MSC_VER
#ifdef __has_include
  #if __has_include(<winapifamily.h>)
    #define HAVE_WINAPIFAMILY 1
  #endif
#elif _MSC_VER >= 1700 && !_USING_V110_SDK71_
  #define HAVE_WINAPIFAMILY 1
#endif
#endif

#ifdef HAVE_WINAPIFAMILY
  #include <winapifamily.h>
  #if !WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_DESKTOP) && WINAPI_FAMILY_PARTITION(WINAPI_PARTITION_APP)
    #define IS_UWP 1
  #endif
#endif

static
int open_gl(void) {
#ifndef IS_UWP
    libGL = LoadLibraryW(L"opengl32.dll");
    if(libGL != NULL) {
        void (* tmp)(void);
        tmp = (void(*)(void)) GetProcAddress(libGL, "wglGetProcAddress");
        gladGetProcAddressPtr = (PFNWGLGETPROCADDRESSPROC_PRIVATE) tmp;
        return gladGetProcAddressPtr != NULL;
    }
#endif

    return 0;
}

static
void close_gl(void) {
    if(libGL != NULL) {
        FreeLibrary((HMODULE) libGL);
        libGL = NULL;
    }
}
#else
#include <dlfcn.h>
static void* libGL;

#if !defined(__APPLE__) && !defined(__HAIKU__)
typedef void* (APIENTRYP PFNGLXGETPROCADDRESSPROC_PRIVATE)(const char*);
static PFNGLXGETPROCADDRESSPROC_PRIVATE gladGetProcAddressPtr;
#endif

static
int open_gl(void) {
#ifdef __APPLE__
    static const char *NAMES[] = {
        "../Frameworks/OpenGL.framework/OpenGL",
        "/Library/Frameworks/OpenGL.framework/OpenGL",
        "/System/Library/Frameworks/OpenGL.framework/OpenGL",
        "/System/Library/Frameworks/OpenGL.framework/Versions/Current/OpenGL"
    };
#else
    static const char *NAMES[] = {"libGL.so.1", "libGL.so"};
#endif

    unsigned int index = 0;
    for(index = 0; index < (sizeof(NAMES) / sizeof(NAMES[0])); index++) {
        libGL = dlopen(NAMES[index], RTLD_NOW | RTLD_GLOBAL);

        if(libGL != NULL) {
#if defined(__APPLE__) || defined(__HAIKU__)
            return 1;
#else
            gladGetProcAddressPtr = (PFNGLXGETPROCADDRESSPROC_PRIVATE)dlsym(libGL,
                "glXGetProcAddressARB");
            return gladGetProcAddressPtr != NULL;
#endif
        }
    }

    return 0;
}

static
void close_gl(void) {
    if(libGL != NULL) {
        dlclose(libGL);
        libGL = NULL;
    }
}
#endif

static
void* get_proc(const char *namez) {
    void* result = NULL;
    if(libGL == NULL) return NULL;

#if !defined(__APPLE__) && !defined(__HAIKU__)
    if(gladGetProcAddressPtr != NULL) {
        result = gladGetProcAddressPtr(namez);
    }
#endif
    if(result == NULL) {
#if defined(_WIN32) || defined(__CYGWIN__)
        result = (void*)GetProcAddress((HMODULE) libGL, namez);
#else
        result = dlsym(libGL, namez);
#endif
    }

    return result;
}

int gladLoadWGL(HDC hdc) {
    int status = 0;

    if(open_gl()) {
        status = gladLoadWGLLoader((GLADloadproc)get_proc, hdc);
        close_gl();
    }

    return status;
}

static HDC GLADWGLhdc = (HDC)INVALID_HANDLE_VALUE;

static int get_exts(void) {
    return 1;
}

static void free_exts(void) {
    return;
}

static int has_ext(const char *ext) {
    const char *terminator;
    const char *loc;
    const char *extensions;

    if(wglGetExtensionsStringEXT == NULL && wglGetExtensionsStringARB == NULL)
        return 0;

    if(wglGetExtensionsStringARB == NULL || GLADWGLhdc == INVALID_HANDLE_VALUE)
        extensions = wglGetExtensionsStringEXT();
    else
        extensions = wglGetExtensionsStringARB(GLADWGLhdc);

    if(extensions == NULL || ext == NULL)
        return 0;

    while(1) {
        loc = strstr(extensions, ext);
        if(loc == NULL)
            break;

        terminator = loc + strlen(ext);
        if((loc == extensions || *(loc - 1) == ' ') &&
            (*terminator == ' ' || *terminator == '\0'))
        {
            return 1;
        }
        extensions = terminator;
    }

    return 0;
}
int GLAD_WGL_VERSION_1_0 = 0;
int GLAD_WGL_ARB_create_context = 0;
int GLAD_WGL_ARB_create_context_profile = 0;
int GLAD_WGL_ARB_pixel_format = 0;
int GLAD_WGL_EXT_swap_control = 0;
PFNWGLCREATECONTEXTATTRIBSARBPROC glad_wglCreateContextAttribsARB;
HGLRC APIENTRY glad_debug_impl_wglCreateContextAttribsARB(HDC arg0, HGLRC arg1, const int * arg2) {    
    HGLRC ret;
    _pre_call_callback("wglCreateContextAttribsARB", (void*)wglCreateContextAttribsARB, 3, arg0, arg1, arg2);
    ret =  glad_wglCreateContextAttribsARB(arg0, arg1, arg2);
    _post_call_callback("wglCreateContextAttribsARB", (void*)wglCreateContextAttribsARB, 3, arg0, arg1, arg2);
    return ret;
}
PFNWGLCREATECONTEXTATTRIBSARBPROC glad_debug_wglCreateContextAttribsARB = glad_debug_impl_wglCreateContextAttribsARB;
PFNWGLGETPIXELFORMATATTRIBIVARBPROC glad_wglGetPixelFormatAttribivARB;
BOOL APIENTRY glad_debug_impl_wglGetPixelFormatAttribivARB(HDC arg0, int arg1, int arg2, UINT arg3, const int * arg4, int * arg5) {    
    BOOL ret;
    _pre_call_callback("wglGetPixelFormatAttribivARB", (void*)wglGetPixelFormatAttribivARB, 6, arg0, arg1, arg2, arg3, arg4, arg5);
    ret =  glad_wglGetPixelFormatAttribivARB(arg0, arg1, arg2, arg3, arg4, arg5);
    _post_call_callback("wglGetPixelFormatAttribivARB", (void*)wglGetPixelFormatAttribivARB, 6, arg0, arg1, arg2, arg3, arg4, arg5);
    return ret;
}
PFNWGLGETPIXELFORMATATTRIBIVARBPROC glad_debug_wglGetPixelFormatAttribivARB = glad_debug_impl_wglGetPixelFormatAttribivARB;
PFNWGLGETPIXELFORMATATTRIBFVARBPROC glad_wglGetPixelFormatAttribfvARB;
BOOL APIENTRY glad_debug_impl_wglGetPixelFormatAttribfvARB(HDC arg0, int arg1, int arg2, UINT arg3, const int * arg4, FLOAT * arg5) {    
    BOOL ret;
    _pre_call_callback("wglGetPixelFormatAttribfvARB", (void*)wglGetPixelFormatAttribfvARB, 6, arg0, arg1, arg2, arg3, arg4, arg5);
    ret =  glad_wglGetPixelFormatAttribfvARB(arg0, arg1, arg2, arg3, arg4, arg5);
    _post_call_callback("wglGetPixelFormatAttribfvARB", (void*)wglGetPixelFormatAttribfvARB, 6, arg0, arg1, arg2, arg3, arg4, arg5);
    return ret;
}
PFNWGLGETPIXELFORMATATTRIBFVARBPROC glad_debug_wglGetPixelFormatAttribfvARB = glad_debug_impl_wglGetPixelFormatAttribfvARB;
PFNWGLCHOOSEPIXELFORMATARBPROC glad_wglChoosePixelFormatARB;
BOOL APIENTRY glad_debug_impl_wglChoosePixelFormatARB(HDC arg0, const int * arg1, const FLOAT * arg2, UINT arg3, int * arg4, UINT * arg5) {    
    BOOL ret;
    _pre_call_callback("wglChoosePixelFormatARB", (void*)wglChoosePixelFormatARB, 6, arg0, arg1, arg2, arg3, arg4, arg5);
    ret =  glad_wglChoosePixelFormatARB(arg0, arg1, arg2, arg3, arg4, arg5);
    _post_call_callback("wglChoosePixelFormatARB", (void*)wglChoosePixelFormatARB, 6, arg0, arg1, arg2, arg3, arg4, arg5);
    return ret;
}
PFNWGLCHOOSEPIXELFORMATARBPROC glad_debug_wglChoosePixelFormatARB = glad_debug_impl_wglChoosePixelFormatARB;
PFNWGLSWAPINTERVALEXTPROC glad_wglSwapIntervalEXT;
BOOL APIENTRY glad_debug_impl_wglSwapIntervalEXT(int arg0) {    
    BOOL ret;
    _pre_call_callback("wglSwapIntervalEXT", (void*)wglSwapIntervalEXT, 1, arg0);
    ret =  glad_wglSwapIntervalEXT(arg0);
    _post_call_callback("wglSwapIntervalEXT", (void*)wglSwapIntervalEXT, 1, arg0);
    return ret;
}
PFNWGLSWAPINTERVALEXTPROC glad_debug_wglSwapIntervalEXT = glad_debug_impl_wglSwapIntervalEXT;
PFNWGLGETSWAPINTERVALEXTPROC glad_wglGetSwapIntervalEXT;
int APIENTRY glad_debug_impl_wglGetSwapIntervalEXT(void) {    
    int ret;
    _pre_call_callback("wglGetSwapIntervalEXT", (void*)wglGetSwapIntervalEXT, 0);
    ret =  glad_wglGetSwapIntervalEXT();
    _post_call_callback("wglGetSwapIntervalEXT", (void*)wglGetSwapIntervalEXT, 0);
    return ret;
}
PFNWGLGETSWAPINTERVALEXTPROC glad_debug_wglGetSwapIntervalEXT = glad_debug_impl_wglGetSwapIntervalEXT;
static void load_WGL_ARB_create_context(GLADloadproc load) {
	if(!GLAD_WGL_ARB_create_context) return;
	glad_wglCreateContextAttribsARB = (PFNWGLCREATECONTEXTATTRIBSARBPROC)load("wglCreateContextAttribsARB");
}
static void load_WGL_ARB_pixel_format(GLADloadproc load) {
	if(!GLAD_WGL_ARB_pixel_format) return;
	glad_wglGetPixelFormatAttribivARB = (PFNWGLGETPIXELFORMATATTRIBIVARBPROC)load("wglGetPixelFormatAttribivARB");
	glad_wglGetPixelFormatAttribfvARB = (PFNWGLGETPIXELFORMATATTRIBFVARBPROC)load("wglGetPixelFormatAttribfvARB");
	glad_wglChoosePixelFormatARB = (PFNWGLCHOOSEPIXELFORMATARBPROC)load("wglChoosePixelFormatARB");
}
static void load_WGL_EXT_swap_control(GLADloadproc load) {
	if(!GLAD_WGL_EXT_swap_control) return;
	glad_wglSwapIntervalEXT = (PFNWGLSWAPINTERVALEXTPROC)load("wglSwapIntervalEXT");
	glad_wglGetSwapIntervalEXT = (PFNWGLGETSWAPINTERVALEXTPROC)load("wglGetSwapIntervalEXT");
}
static int find_extensionsWGL(void) {
	if (!get_exts()) return 0;
	GLAD_WGL_ARB_create_context = has_ext("WGL_ARB_create_context");
	GLAD_WGL_ARB_create_context_profile = has_ext("WGL_ARB_create_context_profile");
	GLAD_WGL_ARB_pixel_format = has_ext("WGL_ARB_pixel_format");
	GLAD_WGL_EXT_swap_control = has_ext("WGL_EXT_swap_control");
	free_exts();
	return 1;
}

static void find_coreWGL(HDC hdc) {
	GLADWGLhdc = hdc;
}

int gladLoadWGLLoader(GLADloadproc load, HDC hdc) {
	wglGetExtensionsStringARB = (PFNWGLGETEXTENSIONSSTRINGARBPROC)load("wglGetExtensionsStringARB");
	wglGetExtensionsStringEXT = (PFNWGLGETEXTENSIONSSTRINGEXTPROC)load("wglGetExtensionsStringEXT");
	if(wglGetExtensionsStringARB == NULL && wglGetExtensionsStringEXT == NULL) return 0;
	find_coreWGL(hdc);

	if (!find_extensionsWGL()) return 0;
	load_WGL_ARB_create_context(load);
	load_WGL_ARB_pixel_format(load);
	load_WGL_EXT_swap_control(load);
	return 1;
}

